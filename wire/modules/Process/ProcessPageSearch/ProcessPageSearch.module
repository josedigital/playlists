<?php

/**
 * ProcessWire Page Search Process
 *
 * Provides page searching within the ProcessWire admin
 *
 * For more details about how Process modules work, please see:
 * /wire/core/Process.php
 *
 * ProcessWire 2.x
 * Copyright (C) 2011 by Ryan Cramer
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 *
 * http://www.processwire.com
 * http://www.ryancramer.com
 *
 */

class ProcessPageSearch extends Process implements ConfigurableModule {

	static public function getModuleInfo() {
		return array(
			'title' => 'Page Search',
			'summary' => 'Provices a page search engine for admin use.',
			'version' => 101,
			'permanent' => true,
			'permission' => 'page-edit',
			);
	}

	protected $nativeSorts = array(
		'relevance',
		'name',
		'title',
		'id',
		'status',
		'templates_id',
		'parent_id',
		'created',
		'modified',
		'modified_users_id',
		'created_users_id',
		'createdUser',
		'modifiedUser',
		'sort',
		'sortfield',
		);

	protected $fieldOptions = array();

	protected $customSorts = array();

	protected $operators = array(
		'=' => 'Equals',
		'!=' => 'Does not equal',
		'>' => 'Greater than',
		'>=' => 'Greater than or equal to',
		'<' => 'Less than',
		'<=' => 'Less than or equal to',
		'*=' => 'Contains phrase or partial word',
		'%=' => 'Contains phrase/word using LIKE',
		'~=' => 'Contains all the words',
		);

	protected $operator = '~=';
	protected $resultLimit = 50;
	protected $maxLimit = 250;

	public function init() {

		foreach($this->fields as $field) {
			if($field->type instanceof FieldtypeFieldsetOpen) continue;
			if($field->type instanceof FieldtypePassword) continue;
			$this->fieldOptions[] = $field->name;
		}

		sort($this->fieldOptions);

		parent::init();
	}


	/**
	 * Perform an interactive search and provide a search form (default)
	 *
	 */
	public function ___execute() {
		$this->processInput();
		list($selector, $displaySelector) = $this->buildSelector();
		$matches = $this->pages->find($selector);
		return $this->render($matches, $displaySelector);
	}

	/**
	 * Perform a non-interactive search (based on URL GET vars)
	 *
	 * This is the preferred input method for links and ajax queries.
	 *
	 * Example /search/for?template=basic-page&body*=example
	 *
	 */
	public function ___executeFor() {

		$selector = '';
		$displaySelector = '';
		$limit = $this->resultLimit;
		$start = 0;
		$status = 0;

		foreach($this->input->get as $name => $value) {

			// operator has no '=', so we'll get the value from the name
			// so that you can do something like: bedrooms>5 rather than bedrooms>=5
			if(!strlen($value) && preg_match('/([^<>]+)\s*([<>])\s*([^<>]+)/', $name, $matches)) {

				$name = $matches[1];
				$operator = $matches[2];
				$value = $matches[3]; 

			} else {

				$operator = substr($name, -1) . '=';

				if(isset($this->operators[$operator])) {
					$name = substr($name, 0, -1); 
				} else {
					$operator = '=';
				}
			}

			$name = $this->sanitizer->fieldName($name); 

			if(!$name) continue; 

			if($name == 'limit') { 
				$limit = (int) $value; 
				$this->input->whitelist('limit', $value);
				continue; 
			}

			if($name == 'start') { 
				$start = (int) $value;
				$this->input->whitelist('start', $value); 
				continue; 
			}

			if($name == 'include' || $name == 'check_access') continue; 
			if($name == 'status') $status = (int) $value;
			if(!$this->isSelectableFieldName($name)) continue; 

			$this->input->whitelist($name . rtrim($operator, '='), trim($value, '"\'')); 	
			$value = $this->sanitizer->selectorValue($value); 
			$selector .= "$name$operator$value, ";
		}

		if($start) $selector .= "start=$start, ";
		$selector .= "limit=$limit, ";

		$selector = rtrim($selector, ", "); 
		$displaySelector = $selector; 

		if($this->user->isSuperuser && !$status) $selector .= ", include=all"; 

		return $this->render($this->pages->find($selector), $displaySelector); 
	}

	/**
	 * Render the search results
	 *
	 */
	protected function render(PageArray $matches, $displaySelector) {

		$out = '';
		if($displaySelector) $this->message("Found " . $matches->getTotal() . " pages using selector: $displaySelector");

		// determine what fields will be displayed
		$display = $this->input->get('get');
		if(!$display) $display = $this->input->get('display'); // display=old terminology
		if(!strlen($display)) $display = 'title path';
		$display = str_replace(',', ' ', $display);
		$display = explode(' ', $display); // convert to array

		foreach($display as $key => $name) {
			$name = $this->sanitizer->fieldName($name);
			$display[$key] = $name; 
			if($this->isSelectableFieldName($name)) continue; 
			if(in_array($name, array('url', 'path', 'httpUrl'))) continue; 
			unset($display[$key]); 
		}
		$this->input->whitelist('get', implode(',', $display)); 

		if($this->config->ajax) {
			// ajax json output
			$out = $this->renderMatchesAjax($matches, $display, $displaySelector); 

		} else {
			// html output
			$class = '';
			if($this->input->get->show_options !== 0 && $this->input->urlSegment1 != 'find') {
				$out = "\n<div id='ProcessPageSearchOptions'>" . $this->renderFullSearchForm() . "</div>";
				$class = 'show_options';
			} 

			$out .= "\n<div id='ProcessPageSearchResults' class='$class'>" . $this->renderMatchesTable($matches, $display) . "\n</div>";
		}

		return $out;
	}

	/**
	 * Build a selector based upon interactive choices from the search form 
	 *
	 */
	protected function buildSelector() {
		$selector = '';

		// search query text
		$q = $this->input->whitelist('q');
		if(strlen($q)) {
			$searchFields = $this->searchFields;
			if(is_string($searchFields)) $searchFields = explode(' ', $searchFields);

			foreach($searchFields as $fieldName) {
				$fieldName = $this->sanitizer->fieldName($fieldName);
				$selector .= "$fieldName|";
			}
			$selector = rtrim($selector, '|') . $this->operator . $q;
		}

		// determine if results are sorted by something other than relevance
		$sort = $this->input->whitelist('sort');
		if($sort && $sort != 'relevance') {
			$reverse = $this->input->whitelist('reverse') ? "-" : '';
			$selector .= ", sort=$reverse$sort";

			// if a specific template isn't requested, then locate the templates that use this field and confine the search to them
			if(!$this->input->whitelist('template') && !in_array($sort, $this->nativeSorts)) {
				$templates = array();
				foreach($this->templates as $template) {
					if($template->fieldgroup->has($sort)) $templates[] = $template->name;
				}
				if(count($templates)) $selector .= ", template=" . implode("|", $templates);
			}
		}

		// determine if search limited to a specific template
		if($this->input->whitelist('template')) $selector .= ", template=" . $this->input->whitelist('template');

		if(!$selector) {
			$this->error("No search specified");
			return '';
		}

		$selector = trim($selector, ", ");

		// highlight the selector that was used
		$displaySelector = $selector;

		// limit results for pagination
		$selector .= ", limit={$this->resultLimit}";

		// include hidden pages
		if($this->user->isSuperuser()) $selector .= ", include=all";
			else $selector .= ", status<" . Page::statusUnpublished;

		return array($selector, $displaySelector); 
	}

	/**
	 * Process input from the search form
	 *
	 */
	protected function processInput() {

		// search fields
		if($this->input->get->field) {
			$field = str_replace(',', ' ', $this->input->get->field);
			$fieldArray = explode(' ', $field);
			$field = '';
			foreach($fieldArray as $f) {
				$f = $this->sanitizer->fieldName($f);
				if(!in_array($f, $this->fieldOptions) && !in_array($f, $this->nativeSorts)) continue;
				$field .= $f . " ";
			}
			$field = rtrim($field, " ");
			if($field) {
				$this->searchFields = $field;
				$this->input->whitelist('field', $field);
			}
		} else {
			$this->input->whitelist('field', $this->searchFields);
		}

		// operator, search type
		$this->operator = '~=';
		if($this->input->get->operator && array_key_exists($this->input->get->operator, $this->operators)) {
			$this->operator = substr($this->input->get->operator, 0, 3);
			$this->input->whitelist('operator', $this->operator);
		}

		// search query
		$q = $this->sanitizer->selectorValue(substr($this->input->get->q, 0, 128));
		$this->input->whitelist('q', $q);

		// sort
		$this->input->whitelist('sort', 'relevance');
		if($this->input->get->sort) {
			$sort = $this->sanitizer->fieldName($this->input->get->sort);
			if($sort && (in_array($sort, $this->nativeSorts) || in_array($sort, $this->fieldOptions))) $this->input->whitelist('sort', $sort);
			if($this->input->get->reverse) $this->input->whitelist('reverse', 1);
		}

		// template
		if($this->input->get->template) {
			$template = $this->sanitizer->name($this->input->get->template);
			if(!$this->templates->get($template)) $template = '';
			if($template) $this->input->whitelist('template', $template);
		}

	}


	/**
	 * Is the given field name selectable?
	 *
	 */
	protected function isSelectableFieldName($name) {
		$is = false;
		if(in_array($name, $this->nativeSorts)) $is = true; 
 			else if(in_array($name, array('parent', 'template'))) $is = true; 
			else if(in_array($name, $this->fieldOptions)) $is = true; 
		if($name == 'pass' || $name == 'config') $is = false;
		return $is; 
	}

	protected function renderFullSearchForm() {

		// Search options

		$out  = "\n\t<p id='wrap_search_query'>" .
			"\n\t<label for='search_query'>Search for:</label>" .
			"\n\t<input id='search_query' type='text' name='q' value='" . htmlentities($this->input->whitelist('q'), ENT_QUOTES, "UTF-8") . "' />" .
			"\n\t<input type='hidden' name='show_options' value='1' />" . 
			"\n\t</p>";

		$out .= "\n\t<p id='wrap_search_field'>" .
			"\n\t<label for='search_field'>Search in field(s):</label>" .
			"\n\t<input type='text' name='field' value='" . htmlentities($this->searchFields, ENT_QUOTES) . "' />" .
			"\n\t</p>";

		$out .= "\n\t<p id='wrap_search_template'>" .
			"\n\t<label for='search_template'>Limit to template: </label>" .
			"\n\t<select id='search_template' name='template'>" .
			"\n\t\t<option></option>";

		$templateName = $this->input->whitelist('template');
		foreach($this->templates as $template) {
			$attrs = $template->name === $templateName ? " selected='selected'" : '';
			$out .= "\n\t<option$attrs>{$template->name}</option>";
		}

		$out .= "\n\t</select>" .
			"\n\t</p>";


		// Advanced

		$out2 =	"\n\t<p id='wrap_search_operator'>" .
			"\n\t<label for='search_operator'>Type of search:</label>" .
			"\n\t<select id='search_operator' name='operator'>" .
			"\n\t\t<option></option>";

		foreach($this->operators as $operator => $desc) {
			$attrs = $this->operator === $operator ? " selected='selected'" : '';
			$out2 .= "\n\t\t<option$attrs value='$operator'>$desc</option>";
		}

		$out2 .= "\n\t</select>" .
			"\n\t</p>";


		$out2 .= "\n\t<p id='wrap_search_display'>" .
			"\n\t<label for='search_display'>Display field(s):</label>" .
			"\n\t<input type='text' name='display' value='" . htmlentities($this->input->whitelist('display'), ENT_QUOTES) . "' />" .
			"\n\t</p>";

		$out2 .= "\n\t<p id='wrap_search_sort'>" .
			"\n\t<label for='search_sort'>Sort by: </label>" .
			"\n\t<select id='search_sort' name='sort'>";

		$sorts = $this->nativeSorts + $this->fieldOptions;

		$sort = $this->input->whitelist('sort');
		foreach($sorts as $s) {
			if(strpos($s, ' ')) continue; // skip over multi fields
			$attrs = '';
			if($s === $sort) $attrs = " selected='selected'";
			$out2 .= "\n\t\t<option$attrs>$s</option>";
		}

		$out2 .= "\n\t</select>" .
			"\n\t</p>";

		if($sort != 'relevance') {
			$out2 .= "\n\t<p id='wrap_search_options'>" .
				"\n\t<label><input type='checkbox' name='reverse' value='1' " . ($this->input->whitelist('reverse') ? "checked='checked' " : '') . "/> Reverse sort?</label>" .
				"\n\t</p>";
		}

		$submit = $this->modules->get("InputfieldSubmit");
		$submit->attr('name', 'submit');
		$submit->attr('value', 'Search');
		$out .= "<p>" . $submit->render() . "</p>";

		$form = $this->modules->get("InputfieldForm");
		$form->attr('id', 'ProcessPageSearchOptionsForm');
		$form->method = 'get';
		$form->action = './';

		$field = $this->modules->get("InputfieldMarkup");
		$field->label = "Search Options";
		$field->value = $out;

		$form->add($field);

		$field = $this->modules->get("InputfieldMarkup");
		$field->collapsed = true;
		$field->label = "Advanced";
		$field->value = $out2;

		$form->add($field);

		$field = $this->modules->get("InputfieldMarkup"); 
		$field->id = 'ProcessPageSearchShortcuts'; 
		$field->collapsed = true; 
		$field->label = "Shortcuts";
		$field->value = $this->renderShortcuts();

		$form->add($field); 

		return $form->render();

	}

	protected function renderShortcuts() {

		$out = '';
		$links = array(
			'Quick Links',
			"All by creation date" => '?q=&submit=Search&display=title+path+created&sort=created&reverse=1' ,
			"All by latest edit date" => '?q=&submit=Search&display=title+path+created&sort=modified&reverse=1',
			"Users by creation date" => '?q=&template=user&submit=Search&operator=~%3D&display=name+email+created&sort=created&reverse=1',
			'New pages by template',
			);

		foreach($this->templates as $template) {
			// Quick links only for content with more than one page
			// if($template->getNumPages() < 2) continue;

			// Users get own quick link earlier, others are rather irrelevant
			if($template->flags & Template::flagSystem) continue; 

			$links[$template->name] = "?q=&template={$template->name}&submit=Search&operator=~%3D&display=title+path+created&sort=created&reverse=1";
		}

		foreach($links as $label => $value) {
			if(is_int($label)) {
				$out .= "<h4>$value</h4>";
			} else {
				$value .= "&show_options=1";
				$value = htmlspecialchars($value); 
				$out .= "<a href='$value'>$label</a>";
			}
		}

		return $out;
	}

	protected function renderMatchesTable(PageArray $matches, array $display, $id = 'ProcessPageSearchResultsList') {

		if(!count($display)) $display = array('path'); 
		$out = '';

		if(!count($matches)) return $out;
		$table = $this->modules->get("MarkupAdminDataTable");
		$table->setSortable(false); 
		$table->setEncodeEntities(false);
		$header = $display;
		$header[] = "";
		$table->headerRow($header);

		foreach($matches as $match) {
			$match->setOutputFormatting(true);
			$editUrl = "{$this->config->urls->admin}page/edit/?id={$match->id}";
			$viewUrl = $match->url();
			$row = array();
			foreach($display as $name) {
				$value = $match->get($name);
				if(is_object($value)) {
					if($value instanceof Page) $value = $value->name;
				}
				$value = strip_tags($value);
				if($name == 'created' || $name == 'modified') $value = date(DATE_ISO8601, $value);
				$row[] = "<a href='$viewUrl'>$value</a>";
			}
			$row[] = $match->editable() ? "<a class='action' href='$editUrl'>edit</a>" : '&nbsp;';
			$table->row($row);

		}

		$pager = $matches->getTotal() > count($matches) ? $matches->renderPager() : '';

		$out = $pager . $table->render() . $pager;

		return $out;
	}

	/**
	 * Render the provided matches as a JSON string for AJAX use
	 *
	 */
	protected function renderMatchesAjax(PageArray $matches, array $display, $selector) {

		$a = array(
			'selector' => $selector, 
			'total' => $matches->getTotal(),
			'limit' => $matches->getLimit(),
			'start' => $matches->getStart(),
			'matches' => array(),
			);

		foreach($matches as $page) {

			$p = array(
				'id' => $page->id, 
				'parent_id' => $page->parent_id, 
				'template' => $page->template->name, 
				'path' => $page->path, 
				'name' => $page->name, 
				);

			foreach($display as $key) {
				$value = $page->get($key);
				if(is_object($value)) $value = $this->setupObjectMatch($value); 
				if(is_array($value)) $value = $this->setupArrayMatch($value);
				$p[$key] = $value;
			}

			$a['matches'][] = $p;
		}

		return json_encode($a); 	
	}

	/**
	 * Convert object to an array where possible, otherwise convert to a string
	 *
	 * For use by renderMatchesAjax
	 *
	 */
	protected function setupObjectMatch($o) {
		if($o instanceof Page) {
			return array(
				'id' => $o->id,
				'parent_id' => $o->parent_id,
				'template' => $o->template->name,
				'name' => $o->name,
				'path' => $o->path,
				'title' => $o->title
			); 
		}
		if($o instanceof WireData || $o instanceof WireArray) return $o->getArray();
		return (string) $o;
	}

	/**
	 * Filter an array converting any indexes containing objects to arrays or strings
	 *
	 * For use by renderMatchesAjax
	 *
	 */
	protected function setupArrayMatch(array $a) {
		foreach($a as $key => $value) {
			if(is_object($value)) $a[$key] = $this->setupObjectMatch($value);
				else if(is_array($value)) $a[$key] = $this->setupArrayMatch($value); 
		}
		return $a; 
	}

	public function renderSearchForm() {

		$q = substr($this->input->get->q, 0, 128);
		$q = htmlentities($q, ENT_QUOTES, "UTF-8");

		$out = 	"\n<form id='ProcessPageSearchForm' action='{$this->config->urls->admin}page/search/' method='get'>" .
			"\n\t<input type='text' id='ProcessPageSearchQuery' name='q' value='$q' />" .
			"\n\t<input type='submit' id='ProcessPageSearchSubmit' name='search' value='Search' />" .
			"\n\t<input type='hidden' name='show_options' value='1' />" . 
			"\n\t<span id='ProcessPageSearchStatus'></span>" .
			"\n</form>";

		return $out;

	}

	static public function getModuleConfigInputfields(array $data) {

		$inputfields = new InputfieldWrapper();

		$inputfield = Wire::getFuel('modules')->get("InputfieldText");
		$inputfield->attr('name', 'searchFields');
		if(!isset($data['searchFields'])) $data['searchFields'] = 'title body';
		if(is_array($data['searchFields'])) $data['searchFields'] = implode(' ', $data['searchFields']);
		$inputfield->attr('value', $data['searchFields']);
		$inputfield->label = "Default fields to search";
		$inputfield->description = "Enter the names for one or more text-based fields that you want to search, separating each by a space. ";
		$inputfields->append($inputfield);

		$inputfield = Wire::getFuel('modules')->get("InputfieldText");
		$inputfield->attr('name', 'displayField');
		$inputfield->attr('value', isset($data['displayField']) ? $data['displayField'] : 'name');
		$inputfield->label = "Default field name(s) to display in search results";
		$inputfield->description = "If specifying more than one field, separate each with a space.";
		$inputfields->append($inputfield);

		return $inputfields;
	}


}
